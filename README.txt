1.Instructions on how to run my code:
After invoking emulator, first invoke the Receiver and then invoke the Sender. 
Syntax for Receiver:
“java Receiver <filename> <listening_port> <sender_IP> <sender_port> <log_file>”
An example is “java Receiver receive.txt 41194 128.59.11.33 41191 log_receiver.txt”
Syntax for Sender:
“java Sender <filename> <remote_IP> <remote_port> <ack_port_num> <log_filename>”
The last argument could be omitted with a result of default value of 1.
Since the file I used to test is called “send.txt”, an example is “java Sender send.txt 160.39.149.188 41192 41191 log_sender.txt 4”. Since the data length of a TCP packet is set to be 1024 bytes and there are 7 packets to be sent. 
In the above examples, 160.39.149.188 is my local ip address. 128.59.11.33 is the Sender’s ip address. 128.59.11.34 is the Receiver’s ip address. And emulator was triggered as “./newudpl -i128.59.11.33/41191 -o128.59.11.34/41194 –d1 -B1000 -L20 -O30”

Then the sender start to sending data to receiver and both programs would be terminated when the data are successfully sent and acknowledged.

2.Brief Description of:
<a> TCP segment structure used. The TCP segment is divided into 2 parts, header with length of 20 and data with length of 1024 bytes. The mainly used structures are sequence number, acknowledge number, FIN flag, chech sum. Most of the other fields are left as 0 while source port, destination port, data offset and ack flag are packed with valid data though not used. Sequence number field is used by the receiver to know about the sequence number of the currently received sequence. Acknowledge number is used by the sender to decide the ack number from received packets. FIN flag is used by both sides to decide the last packet of the file. Since the file length mod length of a data sequence is the length of data part of the last sequence, the sender would use the urgent power bytes to denote the length of the data in that packet while squeeze the space left with 0s. The receiver would parse the last packet based on this design. Check sum field is used by the receiver to decide whether the currently received packet is corrupted by the channel. 
<b> Sender mainly has 3 states, sending, waiting and receiving. Sending is just send out TCP packet. Waiting is the state for each sequence in the current window. When there is a time out for a specific sequence, it would retransmit the packet. Receiving is about receiving the acks from receiver. After successfully receive a ack right to the current window start(leftmost sequence of the window), the window would move as the window start would be the currently received ack value.
The receiver would mainly have two states. The first state is when the currently received packet is corrupted or has already been received, it would just send an ACK with the same value as the previous ACK. The second state is when the currently received packet is successfully received, it needs to figure out what the ACK should be. Since here I implemented the model similar to selective repeat, the following packets may already been received, I used a hash map to store all the received packets and once a new packet is received, it would increase the sequence number until it finds a packet which is not received. (Specially, after the last needed packet is received, the next packed needed would be the packet with number of numOfSeq, which is not a sequence at all, but it doesn’t matter, because as it sends ACK with FIN flag = 1, the sender would know that all packets are successfully received and the link should be closed).
<c> Loss recovery mechanism. The loss recovery mechanism consists of two parts both for the sender and receiver. As mentioned above, the receiver would check the check sum to know if the current packet is a corrupted one. And it would send the same ACK as last time. On the other hand, the sender has timeout for every packets, it would resend the packet if it is still in the window and times out.

3. Descriptions of Unusual things about my implementation.
Since I implemented the selective repeat mode, I need to handle a lot of problems from this. Firstly, to better send and receive packets without blocking the main thread, I implemented other threads to send and receive packets. Then the problem is the program is not serialized and when two threads get access to the same variable or data, it would cause logical problem. To solve this, I implemented queues to send and receive packets. They could be seen as buffers for sending and receiving packets. For sender, 2 queues are needed to take care of both sending packets and receiving ACKs and 1 queue is needed for the receiver as only receiving has this problem while sending ACKs could be done by the same thread when it deals with packets in the queue.
Secondly, because the packets may arrive at the receiver with no order, I implemented a hash table to store all the received packets. After all the packets are received, the receiver would reassembly all the packets in the hash map and write the result to a file as the final result.
Thirdly, about update of RTT. Since my implementation would only acknowledges the next needed packet, we could not know which packet in the window corresponds to this ACK. And following Karn’ Algorithm, those retransmitted packets should participate in the update of RTT. I implemented this as follows: when there is an ACK, the starting time would be the average time of all the packets not retransmitted in the current window. With this sample RTT ,we could update RTT. This is just an approximation for updating RTT.
 
